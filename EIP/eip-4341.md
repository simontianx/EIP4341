---
eip: 4341
title: Multi Ordered NFT Standard
description: A standard retaining and managing the ordering information of multiple NFTs.
author: Simon Tian (@simontianx)
discussions-to: https://github.com/ethereum/EIPs/issues/3782
status: Draft
type: Standards Track,
category: ERC
created: 2021-10-01
replaces (*optional): <EIP number(s)>
---

## Abstract
This standard introduces a smart contract interface that can represent a batch
of non-fungible tokens of which the ordering information shall be retained and
managed. The ordering information of NFTs is particularly useful if `tokenIds`
are encoded with `unicode` and therefore used as carriers of meanings.

## Motivation
Non-fungible tokens are widely accepted as carriers of crypto-assets, hence in both
[ERC721](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md) and [ERC1155](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md), the ordering information of multiple
NFTs is discarded. However, if non-fungible tokens are thought of the basic units
on a blockchain as proposed in [EIP-3754](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3754.md), and the unicoded `tokenIds` are utilized to transmit meanings with emojis and logographic
characters, more business scenarios can be opened up by this standard.

A **[logograph](https://en.wikipedia.org/wiki/Logogram)** is a written character
that represents a word or morpheme, examples include _hanzi_ in Mandarin, _kanji_
in Japanese, _hanja_ in Korean, and etc. A [unicode](https://en.wikipedia.org/wiki/Unicode) is an information technology standard for the consistent encoding, representation, and
handling of texts.

It is natural to combine the two to create unicoded NFTs to represent logographic
characters. Since a rich amount of meanings can be transmitted in just a few
characters, it is technically practical and valuable. Emojis are similar with
logographs and can be included as well. For non-logographic languages such as
English, although the same standard can be applied, it is tedious to represent
each letter with an NFT, hence the gain is hardly justifiable.

A motivating example is instead of sending the two Chinese characters of the
Great Wall `长城`, two NFTs with IDs `#38271` and `#22478` respectively can be
transferred in a batch. The two IDs are corresponding to the decimal unicode of
the two characters. The receiving end decodes the IDs and retrieves the original
characters. A key point is the ordering information matters in this scenario
since the tuples `(38271, 22478)` and `(22478, 38271)` can be decoded as
`长城` and `城长`, respectively, and both are legitimate words in the Chinese
language. This illustrates the key difference between this standard and ERC1155.

Besides, in the eastern Asian culture, characters are sometimes considered or
practically used as gifts in holidays such as Spring Feastival, etc.
`(24685, 21916, 21457, 36001)` `恭喜发财` can be used literally as a gift to
express the best wishes for financial prosperity. That said, logographs do possess
the nature of an asset, which is well resembled by this standard.

What is even more interesting is in that culture, people consider ancient teachings
as treasures which are usually written in a concise way such that a handful of
characters can unfold a rich amount of meanings. Modern people now get a reliable
technical means to pass down their words, poems and proverbs to the future
generations by sending tokens.

Other practical and interesting applications include Chinese chess, wedding
vows, family generation quotes and sayings, funeral commendation words, prayers,
anecdotes and etc.

## Specification
```
pragma solidity ^0.8.0;

/**
    @title EIP-4341 Unicoded NFT Standard
    @dev See https://eips.ethereum.org/EIPS/eip-4341
 */
interface ERC4341 /* is ERC165 */ {
    event Transfer(address indexed _operator, address indexed _from, address indexed _to, uint256 _id);

    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids);

    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, bytes calldata _data) external;

    function balanceOf(address _owner, uint256 _id) external view returns (uint256);

    function balanceOfPhrases(address _owner) external view returns (uint256);

    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);

    function retrievePhrase(address _owner, uint256 _phraseId) external view returns (uint256[] memory);

    function setApprovalForAll(address _operator, bool _approved) external;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}
```

## Rationale
[ERC1155](./eip-1155.md) and [ERC721](./eip-721.md) can be considered as being
in the track of representing crypto-assets with NFTs, then [EIP-3754](./eip-3754.md)
and this standard EIP-4341 are in the track of representing utilities of NFTs.

### Phrase and sentence
A `phrase` together with a `phraseId` is used to keep the ordering information in a
transferred batch of tokenIds. A phrase, usually an ordered sequence of unicodes,
can be stored in an array of unsigned integers. A phrase does not increase or
decrease the amount of any NFT in anyway. It is also not supposed to be disseminated.
The phrase information is kept in storage and hence additional storage than ERC1155
is required. A phrase cannot be transferred, however, it can be retrieved and
decoded to restore the original sequence of unicodes.

## Backwards Compatibility
[EIP-3754](./eip-3754.md) is the pre-requisite to this standard.

## Reference Implementation
https://github.com/simontianx/ERC4341

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
